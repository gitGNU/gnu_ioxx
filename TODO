#+TITLE: ioxx                               -*- mode: org; fill-column: 79; -*-

* Design

** DONE Should there be such a thing as an invalid =ioxx::socket=?

   The design could enforce that a =socket= is always valid, i.e. there would
   be no default constructor and no =release()= method. Is that desirable? Or
   is the additional flexibility of a stateful =socket= implementing =reset()=,
   =swap()=, and =release()= all over the place?

   [2008-04-27 Sun]: The answer is *no*. A =socket= is always valid; any
   attempt to construct an invalid socket throws an exception. A stateful
   socket can be readily emulated by using a socket pointer, i.e. a
   scoped_ptr<socket> or shared_ptr<socket>.

** TODO Will ioxx have a link library?

   Link libraries are a pain in the ass once different kinds of variants are
   involved. At the same time, a lot of socket code can be put into a link
   library just fine; including all those system headers everywhere is plain
   unnecessary.


* Known Bugs and Portability Problems

** TODO Specialization for =size(iovec const &)= doesn't compile with ICC 9.11.

   Boost 1.35 defines that function to return =range_difference<T>::type= --
   the signed type =byte_offset= for us --, but the current specialization
   returns =byte_size=, which is unsigned.

** DONE Boost libraries don't compile on AIX.

   The header-only libraries probably work, but Boost.Build doesn't seem to
   know about the IBM xlC++ compiler. Is it a good idea to use Boost.System
   after all? It's the only link library ioxx really needs at this point. The
   unit tests also need the unit_test_framework, naturally, but not being able
   to build those is a smaller problem than not being able to build the actual
   library. A simple replacement class for =system_error= might make things a
   lot easier.

   [2008-05-02 Fri]: ioxx no longer depends on any boost link libraries;
   everything is header-only.

** DONE Demuxer sockets support no =release()=, =swap()=, or =reset()=.

   The methods are publicly available through inheritance, but at attempt to
   actually use them will break things.

   Related to [[*Should there be such a thing as an invalid =ioxx::socket=?]].

   [2008-04-27 Sun]: It won't have to.

** DONE Add a scoped task class to =schedule=.

   The standard =task_id= is not scoped, i.e. the task is not cancelled on
   destruction. A common use case for scheduled tasks, however, are timeouts,
   and those tasks will exist only for a certain scope, namely the time the
   application is waiting for the i/o operation to complete.

   [2008-05-02 Fri]: Added =schedule<>::timeout=.

** DONE =dispatch::run()= is insufficient

   The function calls =deliver_events()= directly after waiting. This means
   that the active handlers will run with a -- potentially -- screwed up notion
   of 'now' because the user had no chance to update the system timer. There
   are two ways out of this:

   - Split =wait()= out of =run()=, like it is in =demux=.
   - Pass a reference to =time= so that our loop can call =update()=.

** TODO Demux and dispatcher sockets need constructors for weak ownership.

   The demuxers don't forward the dont-close-on-destruction constructor. The
   concept check test should proably enforce that.

** TODO All our classes must accept an allocators object at construction.

   Having a template parameter is nice, but it must be possible to pass a
   concrete instance.

** DONE The =AX_WITH_PROG= macro has some screwed up documentation.

   [2008-04-30 Wed]: [[gnus:nnml:mail.archive#8089][Asked Francesco.]]
   [2008-05-02 Fri]: Fixed.

** DONE Try linking =adns_init()= without =-ladns= first.

   The user may want to specify an entirely different library in =$LIBS=. If
   that is the case, then linking =-ladns= might break a link that would have
   succeeded otherwise.

   [2008-05-02 Fri]: Implemented in AX_HAVE_ADNS.

** TODO Add a dummy DNS server we can use is case ADNS isn't available.


* Documentation

** Is =select()= a multiplexer or a demultiplexer?

   A multiplexer is a device that combines multiple input streams into a single
   output stream. A demultiplexer does the opposite: it splits a single input
   stream into multiple output streams. So how would one interpret a system
   call like =select()=?

   On the one hand, =select()= combines events generated by many sockets into a
   single event stream, i.e. the results obtained by iterating over the
   resulting =fd_set=. In this light, it is a multiplexer.

   On the other hand, =select()= can be regarded as a single event source that
   outputs events that concern many different sockets, which would make it a
   demultiplexer.

   Personally, I prefer to view these mechanism as multiplexers, but I prefer
   the term demultiplexer because the abbreviation "demux" sounds neat.
